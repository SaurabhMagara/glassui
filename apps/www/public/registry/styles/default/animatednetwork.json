{
  "name": "animatednetwork",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "name": "animatednetwork.tsx",
      "content": "\"use client\"\r\n\r\nimport React, { useRef, useEffect, useState } from 'react'\r\nimport { useTheme } from 'next-themes'\r\n\r\ninterface Dot {\r\n  x: number\r\n  y: number\r\n  baseX: number\r\n  baseY: number\r\n  size: number\r\n  color: string\r\n  vx: number\r\n  vy: number\r\n}\r\n\r\nexport default function AnimatedNetwork() {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null)\r\n  const [dots, setDots] = useState<Dot[]>([])\r\n  const [mousePos, setMousePos] = useState<{ x: number; y: number } | null>(null)\r\n  const { theme } = useTheme()\r\n\r\n  const dotCount = 80\r\n  const moveRadius = 120\r\n  const connectionDistance = 150\r\n  const lightColors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6']\r\n  const darkColors = ['#5dade2', '#ec7063', '#58d68d', '#f5b041', '#af7ac5']\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current\r\n    if (!canvas) return\r\n\r\n    const ctx = canvas.getContext('2d')\r\n    if (!ctx) return\r\n\r\n    const resizeCanvas = () => {\r\n      canvas.width = window.innerWidth\r\n      canvas.height = window.innerHeight\r\n    }\r\n\r\n    resizeCanvas()\r\n    window.addEventListener('resize', resizeCanvas)\r\n\r\n    // Initialize dots\r\n    const newDots: Dot[] = []\r\n    for (let i = 0; i < dotCount; i++) {\r\n      newDots.push({\r\n        x: Math.random() * canvas.width,\r\n        y: Math.random() * canvas.height,\r\n        baseX: Math.random() * canvas.width,\r\n        baseY: Math.random() * canvas.height,\r\n        size: Math.random() * 2 + 1,\r\n        color: (theme === 'dark' ? darkColors : lightColors)[Math.floor(Math.random() * 5)],\r\n        vx: (Math.random() - 0.5) * 0.5,\r\n        vy: (Math.random() - 0.5) * 0.5,\r\n      })\r\n    }\r\n    setDots(newDots)\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', resizeCanvas)\r\n    }\r\n  }, [theme]) // Add theme as a dependency\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current\r\n    if (!canvas) return\r\n\r\n    const ctx = canvas.getContext('2d')\r\n    if (!ctx) return\r\n\r\n    let animationFrameId: number\r\n\r\n    const animate = (time: number) => {\r\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\r\n\r\n      // Set background based on theme\r\n      ctx.fillStyle = theme === 'dark' ? '#000000' : '#ffffff'\r\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n      dots.forEach((dot, index) => {\r\n        // Move dots\r\n        dot.x += dot.vx\r\n        dot.y += dot.vy\r\n\r\n        // Bounce off edges\r\n        if (dot.x < 0 || dot.x > canvas.width) dot.vx *= -1\r\n        if (dot.y < 0 || dot.y > canvas.height) dot.vy *= -1\r\n\r\n        if (mousePos) {\r\n          const dx = mousePos.x - dot.x\r\n          const dy = mousePos.y - dot.y\r\n          const distance = Math.sqrt(dx * dx + dy * dy)\r\n\r\n          if (distance < moveRadius) {\r\n            const angle = Math.atan2(dy, dx)\r\n            const push = (1 - distance / moveRadius) * 10\r\n            dot.x -= Math.cos(angle) * push\r\n            dot.y -= Math.sin(angle) * push\r\n          }\r\n        }\r\n\r\n        // Subtle pulsing effect\r\n        const scale = 1 + Math.sin(time * 0.003 + index) * 0.1\r\n\r\n        // Draw connections\r\n        dots.forEach((otherDot, otherIndex) => {\r\n          if (index !== otherIndex) {\r\n            const dx = dot.x - otherDot.x\r\n            const dy = dot.y - otherDot.y\r\n            const distance = Math.sqrt(dx * dx + dy * dy)\r\n\r\n            if (distance < connectionDistance) {\r\n              ctx.beginPath()\r\n              ctx.moveTo(dot.x, dot.y)\r\n              ctx.lineTo(otherDot.x, otherDot.y)\r\n              const gradient = ctx.createLinearGradient(dot.x, dot.y, otherDot.x, otherDot.y)\r\n              gradient.addColorStop(0, dot.color)\r\n              gradient.addColorStop(1, otherDot.color)\r\n              ctx.strokeStyle = gradient\r\n              ctx.lineWidth = 0.5 * (1 - distance / connectionDistance)\r\n              ctx.stroke()\r\n            }\r\n          }\r\n        })\r\n\r\n        // Draw dot\r\n        ctx.beginPath()\r\n        ctx.arc(dot.x, dot.y, dot.size * scale, 0, Math.PI * 2)\r\n        ctx.fillStyle = dot.color\r\n        ctx.fill()\r\n      })\r\n\r\n      animationFrameId = requestAnimationFrame(animate)\r\n    }\r\n\r\n    animate(0)\r\n\r\n    return () => {\r\n      cancelAnimationFrame(animationFrameId)\r\n    }\r\n  }, [dots, mousePos, theme]) // Add theme as a dependency\r\n\r\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\r\n    setMousePos({ x: e.clientX, y: e.clientY })\r\n  }\r\n\r\n  const handleMouseLeave = () => {\r\n    setMousePos(null)\r\n  }\r\n\r\n  return (\r\n    <canvas\r\n      ref={canvasRef}\r\n      onMouseMove={handleMouseMove}\r\n      onMouseLeave={handleMouseLeave}\r\n      className=\"absolute inset-0 w-full h-full z-0\"\r\n    />\r\n  )\r\n}"
    }
  ],
  "type": "components:ui"
}