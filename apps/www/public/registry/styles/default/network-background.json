{
  "name": "network-background",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "name": "network-background.tsx",
      "content": "\"use client\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { motion } from \"framer-motion\";\r\nimport { useTheme } from \"next-themes\";\r\n\r\nconst NetworkBackground: React.FC<{ className?: string }> = ({ className }) => {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const { theme } = useTheme();\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const ctx = canvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    canvas.width = window.innerWidth;\r\n    canvas.height = window.innerHeight;\r\n\r\n    const particles: Particle[] = [];\r\n    const particleCount = 100;\r\n    const connectionDistance = 150;\r\n\r\n    class Particle {\r\n      x: number;\r\n      y: number;\r\n      size: number;\r\n      speedX: number;\r\n      speedY: number;\r\n\r\n      constructor() {\r\n        this.x = Math.random() * canvas.width;\r\n        this.y = Math.random() * canvas.height;\r\n        this.size = Math.random() * 3 + 1;\r\n        this.speedX = Math.random() * 3 - 1.5;\r\n        this.speedY = Math.random() * 3 - 1.5;\r\n      }\r\n\r\n      update() {\r\n        this.x += this.speedX;\r\n        this.y += this.speedY;\r\n\r\n        if (this.x > canvas.width) this.x = 0;\r\n        else if (this.x < 0) this.x = canvas.width;\r\n        if (this.y > canvas.height) this.y = 0;\r\n        else if (this.y < 0) this.y = canvas.height;\r\n      }\r\n\r\n      draw(color: string) {\r\n        ctx!.fillStyle = color;\r\n        ctx!.beginPath();\r\n        ctx!.arc(this.x, this.y, this.size, 0, Math.PI * 2);\r\n        ctx!.fill();\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < particleCount; i++) {\r\n      particles.push(new Particle());\r\n    }\r\n\r\n    function animate() {\r\n      ctx!.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n      const particleColor = \"rgba(128, 128, 128, 0.8)\"; // Changed to gray\r\n      const lineColor = theme === 'dark' ? \"255, 255, 255\" : \"0, 0, 0\";\r\n\r\n      for (let i = 0; i < particles.length; i++) {\r\n        particles[i].update();\r\n        particles[i].draw(particleColor);\r\n\r\n        for (let j = i; j < particles.length; j++) {\r\n          const dx = particles[i].x - particles[j].x;\r\n          const dy = particles[i].y - particles[j].y;\r\n          const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n          if (distance < connectionDistance) {\r\n            ctx!.strokeStyle = `rgba(${lineColor}, ${1 - distance / connectionDistance})`;\r\n            ctx!.lineWidth = 1;\r\n            ctx!.beginPath();\r\n            ctx!.moveTo(particles[i].x, particles[i].y);\r\n            ctx!.lineTo(particles[j].x, particles[j].y);\r\n            ctx!.stroke();\r\n          }\r\n        }\r\n      }\r\n\r\n      requestAnimationFrame(animate);\r\n    }\r\n\r\n    animate();\r\n\r\n    const handleResize = () => {\r\n      canvas.width = window.innerWidth;\r\n      canvas.height = window.innerHeight;\r\n    };\r\n\r\n    window.addEventListener(\"resize\", handleResize);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", handleResize);\r\n    };\r\n  }, [theme]);\r\n\r\n  const bgClass = theme === 'dark' \r\n    ? \"bg-gradient-to-br from-gray-900 to-gray-800\" \r\n    : \"bg-gradient-to-br from-gray-100 to-white\";\r\n\r\n  return (\r\n    <motion.div\r\n      className={`absolute inset-0 ${className}`}\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      transition={{ duration: 1 }}\r\n    >\r\n      <canvas\r\n        ref={canvasRef}\r\n        className={`w-full h-full ${bgClass}`}\r\n      />\r\n    </motion.div>\r\n  );\r\n};\r\n\r\nexport default NetworkBackground;"
    }
  ],
  "type": "components:ui"
}